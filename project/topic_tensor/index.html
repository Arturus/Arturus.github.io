<!DOCTYPE html>
<html lang="ru">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 3.0.0">
  <meta name="generator" content="Hugo 0.53" />
  <meta name="author" content="Артур Суилин">

  
  
  
  
    
  
  <meta name="description" content="Создание embeddings для формирования и определения тематик Instagram постов и тематик блогеров. Подбор блогеров по тематикам, тематические lookalikes и другие применения.">

  
  <link rel="alternate" hreflang="ru" href="https://suilin.ru/project/topic_tensor/">

  


  

  

  

  
  
  
  <meta name="theme-color" content="#086377">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css" integrity="sha384-5sAR7xN1Nv6T6+dT2mhtzEpVJvfS3NScPQTrOxhwjIuvcA67KV2R5Jz6kr4abQsz" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous">
      
    

    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira+Sans+Condensed:400,400italic,700|PT+Mono|Fira+Sans|PT+Serif:400,400italic,700">
  

  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-38480657-1', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  
  <link rel="alternate" href="https://suilin.ru/index.xml" type="application/rss+xml" title="Артур Суилин">
  <link rel="feed" href="https://suilin.ru/index.xml" type="application/rss+xml" title="Артур Суилин">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://suilin.ru/project/topic_tensor/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@asuilin">
  <meta property="twitter:creator" content="@asuilin">
  
  <meta property="og:site_name" content="Артур Суилин">
  <meta property="og:url" content="https://suilin.ru/project/topic_tensor/">
  <meta property="og:title" content="TopicTensor: тематики в Instagram | Артур Суилин">
  <meta property="og:description" content="Создание embeddings для формирования и определения тематик Instagram постов и тематик блогеров. Подбор блогеров по тематикам, тематические lookalikes и другие применения.">
  
  
    
  <meta property="og:image" content="https://suilin.ru/img/project/topic_tensor/incredible.png">
  <meta property="og:locale" content="ru">
  
  <meta property="article:published_time" content="2018-06-27T00:00:00&#43;04:00">
  
  <meta property="article:modified_time" content="2018-06-27T00:00:00&#43;04:00">
  

  

  <meta property="og:type" content="article"/>
<meta name="yandex-verification" content="5753f991e1c3d96c" />
<meta name="google-site-verification" content="5sd_7MZqiS3rR-1B3f-FqUkrWEd92TYr9FNEGkFE14I" />

<script type="text/javascript" >
  (function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
      try {
        w.yaCounter21550249 = new Ya.Metrika2({
          id:21550249,
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
        });
      } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
      s = d.createElement("script"),
      f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = "https://mc.yandex.ru/metrika/tag.js";

    if (w.opera == "[object Opera]") {
      d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
  })(document, window, "yandex_metrika_callbacks2");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/21550249" style="position:absolute; left:-9999px;" alt="" /></div></noscript>



  <title>TopicTensor: тематики в Instagram | Артур Суилин</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >

<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Артур Суилин</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Переключить навигацию">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav ml-auto">
        

        

        
        
        

        <li class="nav-item">
          <a class="nav-link" href="/">
            
            <span>Главная</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/post/">
            
            <span>Блог</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/project/">
            
            <span>Проекты</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#contact">
            
            <span>Контакты</span>
            
          </a>
        </li>

        
        

      

        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article article-project" itemscope itemtype="http://schema.org/Article">

  









<div class="article-header">
  
  
  <img src="/img/project/topic_tensor/incredible.png" class="article-banner" itemprop="image" alt="">
  

  <span class="article-header-caption">Тематика, сформированная по тэгу #incredible</span>
</div>




  

  
  
  
<div class="article-container pt-3">
  <h1 itemprop="name">TopicTensor: тематики в Instagram</h1>

  
  <p class="page-subtitle">Проект был выполнен для компании Deep.Social</p>
  

  
    

<div class="article-metadata">

  
  
  <span itemscope itemprop="author" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Артур Суилин">
  </span>
  

  <span class="article-date">
    
    <meta content="2018-06-27 00:00:00 &#43;0400 &#43;04" itemprop="datePublished">
    <time datetime="2018-06-27 00:00:00 &#43;0400 &#43;04" itemprop="dateModified">
      27.06.2018
    </time>
  </span>
  <span itemscope itemprop="publisher" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Артур Суилин">
  </span>

  

  
  

  

  
  

  

</div>

  
</div>



  <div class="article-container">
    

    <div class="article-style" itemprop="articleBody">
      

<h2 id="проблема-подбора-блогеров">Проблема подбора блогеров</h2>

<p>У рекламодателей, использующих продвижение товаров и услуг через посты инфлюэнсеров, есть большая проблема,
 которая называется таргетирование. Если рекламодатель даёт рекламу, например,
 через AdWords, он может сфокусироваться по ключевым словам на сколь угодно узкий тематический сегмент аудитории,
  точно соответствующий тем товарам и услугами, которые он продвигает на рынок.
 В социальных сетях такой возможности нет: в Instagram миллионы потенциальных инфлюэнсеров,
  у которых можно разместить рекламу. Каким образом выбрать из них тех, тематика которых подходит рекламодателю?
Или рекламодатель должен сам активно пользоваться Инстаграмом и априори знать тех блогеров,
которые ему подойдут (т.е. только крупных и только тех, на кого он сам подписан).
Или просто давать рекламу наугад, надеясь что она дойдет до хотя бы небольшого процента целевой аудитории.
Понятно, что оба варианта не очень хороши, поэтому для нишевых средних и мелких рекламодателей Инстаграм малоэффективен.</p>

<p>Если решить эту проблему, реклама в Инстаграме доступной и удобной для всех, а не только для крупных брендов.</p>

<h2 id="тематический-рубрикатор-спасибо-не-надо">Тематический рубрикатор? Спасибо, не надо.</h2>

<p>Самый очевидный путь разделения блогеров на тематические сегменты это
 тематический рубрикатор. Для этого сначала вручную создаётся дерево тематик.
 Затем каждый блогер вручную или с помощью машинного обучения соотносится с рубриками этого дерева.</p>

<p>Этим путём идёт большинство рекламных систем, включая такие крупные, как Facebook Ads.
  Но на самом деле это неэффективное решение.
   Количество потенциально интересных рекламодателям тематик очень велико.
 Не будет ошибкой сказать, что оно потенциально бесконечно: чем более в узкой нише работает рекламодатель,
  тем более мелкое дробление на тематики ему требуется.</p>

<ul>
<li>Например, есть тематика <strong>Еда</strong>.</li>
<li>Очевидно, что ресторану нужна не просто <strong>Еда</strong>, а <strong>Еда : Рестораны</strong>.</li>
<li>Если это ресторан тайской кухни, то нужна еще более узкая тематика <strong>Еда : Рестораны : Тайская кухня</strong>.</li>
<li>Если этот ресторан находится в Лондоне, неплохо бы добавить и тематику <strong>Еда : Рестораны : Лондон</strong>, и так далее.</li>
</ul>

<p>Но дерево тематик не может расти бесконечно:</p>

<ol>
<li>C ним станет банально неудобно работать рекламодателю.
Размер рубрикатора, который без усилий может воспринять и удержать в голове обычный человек &ndash; не больше 100 пунктов.</li>
<li>Чем больше рубрик, тем сложнее отнести блогера к конкретным рубрикам и тем больший объем работы для этого нужен.
Сделать эту работу вручную (блогеров &ndash; несколько миллионов) вообще невозможно.
Можно использовать машинное обучение, но всё равно сначала надо составить обучающую выборку,
т.е. образцы правильной разметки блогеров тематиками. Её составляют люди, люди делают ошибки,
люди субъективны в своих взглядах и оценках (разные асессоры отнесут одного и того же блогера к разным рубрикам).
Если учесть, что многие блогеры работают одновременно в нескольких тематиках, проблема еще больше усложняется.</li>
<li>Придётся тратить много усилий на поддержание рубрикатора в актуальном состоянии
(постоянно появляются новые тренды, открываются новые тематики и отмирают старые),
и на обновление обучающей выборки.</li>
</ol>

<p>Получается, что маленькое дерево тематик будет слишком негибким и давать слишком грубое деление,
а с большим деревом будет неудобно работать и рекламодателю, и его создателям. Необходимо другое решение.</p>

<p><img src="topic_tree.jpg" width="560"/></p>

<h2 id="тематику-задаёт-сам-рекламодатель">Тематику задаёт сам рекламодатель</h2>

<p>Что, если тематику можно будет задавать набором ключевых слов, как в AdWords?
Тогда рекламодатель сам сможет настроить для себя любую, сколь угодно узкую тематику,
 и ему при этом не надо будет ползать по огромному рубрикатору.
 Но в AdWords ключевые слова соответствуют тому, что явным образом ищут потенциальные клиенты,
  а чему должны соответствовать ключевые слова в Instagram? Хэштэгам? Но здесь всё не так просто.</p>

<ol>
<li>Блогер, пишущий про автомобили, совсем не обязательно будет употреблять хэштэг <code>#car</code>,
он может использовать <code>#auto</code>, <code>#fastcars</code>, <code>#wheels</code>, <code>#drive</code> или названия брендов <code>#bmw</code>,  <code>#audi</code> и т.п.
Как рекламодатель должен догадаться, какие конкретно тэги используют блогеры?
В принципе эта же проблема есть и в AdWords: рекламодателю надо приложить немалые усилия,
чтобы охватить все возможные ключевые слова в его тематике.</li>
<li>Блогер может случайно употребить хэштэг, например <code>#car</code>, если он купил новый авто,
или просто увидел и сфотографировал интересный автомобиль на улице.
Это совсем не значит, что он пишет на автомобильную тематику.</li>
<li>Блогеры часто используют популярные тэги, не имеющие никакого отношения к тематике поста,
просто чтобы попасть в поисковую выдачу по тэгу (hashtag spam).
Например тэгом <code>#cat</code> может быть помечено и фото бородатого хипстера, и пейзаж с закатом,
и селфи себя любимой в новом наряде и в окружении подруг.<br /></li>
</ol>

<p>Поэтому подбор блогеров просто по наличию у них тэгов, заданных рекламодателем, будет работать плохо.
Нужны более интеллектуальные способы решения этой задачи.</p>

<h2 id="тематическое-моделирование-теория">Тематическое моделирование, теория</h2>

<p>В современных методиках обработки естественного языка
есть область, называемая <em>тематическое моделирование</em> (topic modeling). Проще всего
объяснить применение тематического моделирования к нашей проблеме на простом примере.</p>

<p>Представим очень примитивную социальную сеть, в которой у людей есть всего два основных интереса
  - интерес к еде (<em>Food</em>), и интерес к Японии (<em>Japan</em>).
Если “силу” интереса сопоставить с числом от 0 до 1, то любые хэштэги, используемые блогерами,
можно поместить на 2D диаграмму.</p>




<figure>

<img src="tags2d.png" alt="Пример задания тематик на двумерном пространстве" width="600" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Пример задания тематик на двумерном пространстве
    
    
    
  </p> 
</figcaption>

</figure>

<p>Видно, что любой хэштэг можно описать парой чисел, соответствующих координатам X и Y в тематическом пространстве.
Тэги, относящиеся к одной тематике, группируются в кластера, т.е. у них близкие координаты.
Пользуясь этой диаграммой, можно вычислить релевантность поста тематикам, рассчитав по всем тэгам,
 входящим в пост, его “усредненные” координаты в тематическом пространстве (т.е. получив
  <a href="https://en.wikipedia.org/wiki/Centroid" target="_blank">центроид</a>). Координаты центроида по осям X и Y
будут соответствовать релевантности поста тематикам <em>Food</em> и <em>Japan</em>, чем координата ближе к 1,
тем выше релевантность. Таким же образом рассчитав центроид всех постов блогера,
можно понять, каким тематикам в целом релевантен контент у блогера.</p>

<p>В реальном тематическом моделировании конечно используется не две тематики, а десятки и сотни,
соответственно тэги существуют в high-dimensional пространстве. Более математическое определение:</p>

<ul>
<li>Существует множество документов $D$ (в нашем случае это посты), множество
слов $W$ (в нашем случае тэги) и множество тематик $T$, размер которого задан заранее.</li>
<li>Содержимое документов можно представить как набор пар документ-слово:
$(d, w), d \in D, w \in W_d$</li>
<li>Каждая тематика $t \in T$ описывается неизвестным распределением $p(w|t)$ на множестве слов $w \in W$</li>
<li>Каждый документ $d\in D$ описывается неизвестным распределением $p(t|d)$ на множестве тем $t\in T$</li>
<li>Предполагается, что распределение слов в документах зависит только от тематики: $p(w|t,d)=p(w|t)$</li>
<li>В процессе построения тематической модели алгоритм находит матрицу &ldquo;слово&ndash;тематика&rdquo;
$\mathbf{\Phi} =||p(w|t)||$ и матрицу &ldquo;тематика&ndash;документ&rdquo; $\mathbf{\Theta} =||p(t|d)||$ по содержимому коллекции $D$.
Нас интересует первая матрица.</li>
</ul>

<p>Тематическое моделирование эквивалентно <a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization" target="_blank">неотрицательному
матричному разложению</a>
(NMF, Non-negative matrix factorization). На входе есть разреженная матрица
&ldquo;cлово-документ&rdquo; $\mathbf{S} \in \mathbb{R}^{W \times D}$, описывающая
 вероятность встретить слово $w$ в документе $d$. Вычисляется её аппроксимация
в виде произведения низкоранговых матриц
 $\mathbf{\Phi} \in \mathbb{R}^{W \times T}$ и $\mathbf{\Theta} \in \mathbb{R}^{T \times D}$.
$$\mathbf{S} \approx \mathbf{\Phi}\mathbf{\Theta}$$
Более подробная информация по тематическому моделированию и его алгоритмам есть в <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank">Википедии</a>.</p>

<h2 id="тематическое-моделирование-практика">Тематическое моделирование, практика</h2>

<p>На практике тематическое моделирование показало посредственные
результаты. В таблице представлены результаты моделирования по 15 тематикам с помощью
библиотеки <a href="https://github.com/bigartm/bigartm" target="_blank">BigARTM</a>:</p>

<table>
<thead>
<tr>
<th>Тематика</th>
<th>Топ тэги</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>sky, clouds, sea, spring, baby, ocean, nyc, flower, landscape, drinks</td>
</tr>

<tr>
<td>1</td>
<td>beer, vintage, chill, school, rainbow, yoga, rock, evening, chicago, relaxing</td>
</tr>

<tr>
<td>2</td>
<td>sweet, chocolate, dance, rain, nike, natural, anime, old, wcw, reflection</td>
</tr>

<tr>
<td>3</td>
<td>foodporn, breakfast, delicious, foodie, handmade, gold, instafood, garden, healthy, vegan</td>
</tr>

<tr>
<td>4</td>
<td>architecture, california, lights, portrait, newyork, wine, blonde, familytime, losangeles, thanksgiving</td>
</tr>

<tr>
<td>5</td>
<td>nature, travel, autumn, london, fall, trees, tree, photoshoot, city, cake</td>
</tr>

<tr>
<td>6</td>
<td>flowers, design, inspiration, artist, goals, illustration, pizza, ink, glasses, money</td>
</tr>

<tr>
<td>7</td>
<td>winter, snow, catsofinstagram, sexy, cats, cold, quote, fire, disney, festival</td>
</tr>

<tr>
<td>8</td>
<td>work, mountains, paris, football, nails, video, florida, diy, free, japan</td>
</tr>

<tr>
<td>9</td>
<td>dog, puppy, wedding, dogsofinstagram, dogs, roadtrip, painting, trip, thankful, pet</td>
</tr>

<tr>
<td>10</td>
<td>coffee, quotes, river, yum, moon, streetart, sleepy, music, adidas, positivevibes</td>
</tr>

<tr>
<td>11</td>
<td>style, fashion, party, home, model, music, dress, goodvibes, couple, tired</td>
</tr>

<tr>
<td>12</td>
<td>fitness, motivation, gym, workout, drawing, dinner, fit, sketch, health, fresh</td>
</tr>

<tr>
<td>13</td>
<td>beach, lake, usa, shopping, hiking, fashion, kids, park, freedom, sand</td>
</tr>

<tr>
<td>14</td>
<td>makeup, cat, yummy, eyes, snapchat, homemade, tattoo, kitty, lips, mom</td>
</tr>
</tbody>
</table>

<p>Видно, что какая то разумная структура прослеживается, но тематики далеки от совершенства.
Увеличение количества тематик до 150 даёт сравнительно небольшое улучшение.</p>

<p>Возможно, причина в том, что тематическое моделирование рассчитано на работу с документами, содержащими
сотни и тысячи слов. В нашем случае у большинства постов есть всего 2-3 тэга.</p>

<p>У BigARTM есть большое количество гиперпараметров и возможных способов их применения
(в начале обучения, в конце, ко всем тематикам, к отдельным тематикам и т.п.).
Возможно, при некоторых настройках результат был бы лучше,
но TopicTensor это коммерческий проект, подразумевающий лимиты времени на реализацию.
С тематическим моделированием был риск потратить всё проектное время на подбор гиперпараметров,
и так и не получить удовлетворительный результат на выходе. Другие библиотеки ( <a href="https://radimrehurek.com/gensim" target="_blank">Gensim</a>,
 <a href="http://mallet.cs.umass.edu/topics.php" target="_blank">Mallet</a>)
тоже показали весьма скромные результаты.</p>

<p>Поэтому был выбран другой,
более простой и в то же время более мощный способ моделирования.
$ \newcommand{\sim}[2]{\operatorname{sim}(#1,#2)} $</p>

<h2 id="модель-topictensor">Модель TopicTensor</h2>

<p>Основной плюс тематического моделирования это интерпретируемость полученных
результатов. Для любого слова/тэга на выходе получается набор весов, показывающих,
насколько близко это слово к каждой тематике из всего набора.</p>

<p>Но этот же плюс накладывает серьезные ограничения на модель, вынуждая её
укладываться строго в фиксированное количество тематик, не больше и не меньше.
В реальной жизни количество тематик большой социальной сети практически бесконечно.
Поэтому, если убрать требование по интерпретируемости тематик (и их фиксированному количеству),
обучение станет более эффективным.</p>

<p>В результате получается модель, близкая по смыслу к хорошо известной модели <a href="https://en.wikipedia.org/wiki/Word2vec" target="_blank">Word2Vec</a>.
Каждый тэг представлен в виде вектора в $N$-мерном пространстве: $w \in \mathbb{R}^N$.
Степень схожести (т.е. насколько близки тематики) между тэгами $w$ и $w&rsquo;$ может вычисляться как скалярное произведение (dot product):
$$\sim{w}{w&rsquo;}=w \cdot w&rsquo;$$
как Евклидово расстояние:
 $$\sim{w}{w&rsquo;}=\|w-w&rsquo;\|$$
как cosine similarity:
$$\sim{w}{w&rsquo;}=\cos(\theta )=\frac{w \cdot w&rsquo;}{\|w \|\|w&rsquo; \|}$$</p>

<p>Задача модели в ходе обучения - найти такие представления тэгов, которые будут полезны
для одного из предсказаний:</p>

<ul>
<li>На основе одного тэга предсказать, какие ещё тэги будут включены в пост (архитектура Skip-gram)</li>
<li>На основе всех тэгов поста, кроме одного, предсказать недостающий тэг (архитектура CBOW, &ldquo;мешок слов&rdquo;)</li>
<li>Взять два случайных тэга из поста, и на основе первого предсказать второй</li>
</ul>

<p>Все эти предсказания сводятся к тому, что есть целевой тэг $w_t$ , который надо предсказать,
и контекст $c$, представленный одним или несколькими тэгами, входящими в пост. Модель
должна максимизировать вероятность тэга в зависимости от контекста, это можно представить
в виде softmax критерия:</p>

<p>$$P(w_t|c) = \operatorname{softmax}(\sim{w_t}{c})$$
$$P(w_t|c) = \frac{\exp(\sim{w_t}{c})}{\sum_{w&rsquo; \in W}\exp(\sim{w&rsquo;}{c})}$$</p>

<p>Но вычислять softmax по всему множеству тэгов $W$ дорого (в обучении может участвовать миллион тэгов и более),
поэтому вместо него используются альтернативные способы. Они сводятся к тому, что есть позитивный
пример $(w_t,c)$, который надо предсказать, и случайно выбранные негативные примеры
$(w_1^{-}, c), (w_2^{-}, c),\dots,(w_n^{-}, c)$ являющиеся образцом того, как <em>не надо</em> предсказывать.
Негативные примеры должны сэмплироваться из того же распределения частот тэгов, что и в обучающих данных.</p>

<p>Loss функция по набору примеров может иметь вид бинарной классификации (Negative sampling в классическом Word2Vec)
$$L = \log(\sigma(\sim{w_t}{c})) +  \sum_i\log(\sigma(-\sim{w_i^-}{c}))$$
$$\sigma(x) = \frac{1}{1+e^{-x}}$$
или работать как ranking loss, попарно сравнивая &ldquo;совместимость&rdquo; с контекстом позитивного и негативного примеров:
$$L = \sum_{i} l(\sim{w_t}{c}, \sim{w_i^-}{c})$$
гдe $l(\cdot, \cdot)$ это ranking функция, в качестве которой часто используют
max margin loss:
$$l=\max(0,\mu+\sim{w_i^-}{c}−\sim{w_t}{c})$$</p>

<p>Модель TopicTensor также эквивалентна матричной
факторизации, только вместо матрицы &ldquo;документ-слово&rdquo; (как в тематическом моделировании)
здесь факторизуется матрица &ldquo;контекст-тэг&rdquo;, которая в при некоторых типах предсказаний
превращается в матрицу взаимной встречаемости тэгов &ldquo;тэг-тэг&rdquo;.</p>

<h2 id="практическая-реализация-topictensor">Практическая реализация TopicTensor</h2>

<p>Были рассмотрены несколько возможных способов реализации модели: код на <a href="https://www.tensorflow.org/" target="_blank">Tensorflow</a> ,
код на <a href="https://pytorch.org/" target="_blank">PyTorch</a>, библиотека <a href="https://radimrehurek.com/gensim/" target="_blank">Gensim</a>,
 библиотека <a href="https://github.com/facebookresearch/StarSpace" target="_blank">StarSpace</a>.
Выбран последний вариант, как
требующий минимальных усилий на доработку (вся необходимая функциональность уже есть),
дающий высокое качество, и практически линейно распараллеливающийся на любое количестве
ядер (для ускорения обучения использовалась 32 и 64-ядерные машины).</p>

<p>StarSpace по умолчанию использует loss функцию <em>max margin ranking loss</em>
и <em>cosine distance</em> как метрику близости векторов. Последующие эксперименты
с гиперпараметрами показали, что эти установки по умолчанию являются оптимальными.</p>

<h3 id="подбор-гиперпараметров">Подбор гиперпараметров</h3>

<p>Перед финальным
обучением проводился подбор гиперпараметров, с целью найти баланс между качеством
и приемлемым временем обучения.
Качество замерялось так: бралась выборка постов, которые модель не видела в ходе
обучения. Для каждого тэга из поста (всего в посте $n$ тэгов) находились наиболее близкие ему
тэги-кандидаты по критерию cosine similarity из множества всех тэгов $W$:
$$candidates_i=\operatorname{top_n}(\sim{w_t}{w&rsquo;}, \forall w&rsquo; \in W)$$
$$i \in 1 \dots n$$
Подсчитывалось, сколько из этих кандидатов совпало с реальными тэгами в посте (число совпадений $n^{+}$).
$$quality=\frac{\sum n^+}{\sum n}$$
Качество &ndash; процент правильно угаданных тэгов по всем постам из выборки.
Такая оценка качества наиболее близка к использованию модели в реальной жизни,
когда пользователь будет задавать в большинстве случаев один стартовый тэг и подбирать по нему остальные
тэги, блогеров, и т.д.</p>

<p>Эта оценка также подразумевает, что наиболее оптимально обучать модель по skip-gram
критерию (по одному тэгу предсказывать остальные). Это подтвердилось на
практике: skip-gram обучение показало наилучшее качество, хотя оказалось и самым медленным.</p>

<p>Подбирались следующие гиперпараметры:</p>

<ul>
<li>Размерность векторов</li>
<li>Кол-во эпох для обучения</li>
<li>Кол-во негативных примеров</li>
<li>Learning rate</li>
<li>Undersampling и oversampling</li>
</ul>

<p>Последний гиперпараметр связан с тем, что на постах с малым количеством тэгов обучение
происходит быстрее, чем на постах с большим количеством тэгов. StarSpace за один проход
случайным образом выбирает из поста только один целевой тэг. Таким образом за 20 эпох
каждый тэг из поста, содержащего 2 целевых тэга, побудет целевым в среднем 10 раз, а каждый
тэг из поста, содержащего 20 тэгов &ndash; в среднем только один раз. На коротких списках
тэгов модель переобучится, а на длинных наоборот недообучится. Чтобы избежать этого,
&ldquo;коротким&rdquo; постам надо делать undersampling, а &ldquo;длинным&rdquo; &ndash; oversampling.</p>

<h3 id="подготовка-данных">Подготовка данных</h3>

<p>Тэги были нормализованы: приведены к lowercase, убраны диакритические знаки (за исключением случаев,
где знак влияет на смысл слова)</p>

<p>Для обучения отобраны тэги, встречающиеся в обучающей выборке
не менее N раз у разных блогеров, чтобы обеспечить
разнообразие контекстов их использования (в зависимости от языка N
варьировалось от 20 до 500).</p>

<p>Для каждого языка была сделана выборка из топ 1000 самых распространенных тэгов, и в этой
выборке внесены в blacklist общеупотребительные слова,
 не несущие тематической нагрузки (me, you, together, etc), числительные,
названия цветов (красный, желтый, и т.п.), и некоторые тэги, особенно любимые спамерами.</p>

<p>Тэги каждого блогера перевзвешены в соответствии с частотой их употребления этим блогером.
У большинства блогеров есть &ldquo;любимые&rdquo; тэги и сочетания, используемые почти в каждом посте, и если не понизить их вес,
активно пишущий блогер может перекосить глобальную статистику по употреблению любимых им тэгов и модель обучится под вкусы
этого блогера.</p>

<p>В финальную обучающую выборку попало около 8 млрд тэгов из 1 млрд постов.
Обучение шло более трех недель на 32-ядерном сервере.</p>

<h2 id="результаты">Результаты</h2>

<p>Полученные embeddings показали отличное разделение тематик, хорошую
способность к генерализации и устойчивость к спам-тэгам.</p>

<p>Демо-выборка top 10К тэгов (только английский язык) <a href="http://projector.tensorflow.org/?config=https://gist.githubusercontent.com/Arturus/5dc4d72432e0fc2a5d6f543178a39f1f/raw/790392fe844d86eb46a5ac07622ac6715f8c67de/sample.json" target="_blank">доступна для просмотра</a>
в Embedding Projector. Перейдя по ссылке, надо переключиться в режим t-SNE
 (tab в левой нижней части) и подождать примерно 500 итераций, пока
 не построится проекция в 3D. Просматривать лучше в режиме <code>Color By = logcnt</code>.
Если не хочется ждать, в правом нижнем
 углу есть раздел <code>Bookmarks</code>, в нём выбрать <code>Default</code>, тогда сразу загрузится
 уже рассчитанная проекция.</p>

<h3 id="примеры-формирования-тематик">Примеры формирования тематик</h3>

<p>Начнём с самого простого. Зададим тематику одним тэгом и найдем топ 50
релевантных тэгов.



<figure>

<img src="bmw.png" alt="Тематика, заданная тэгом `#bmw`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгом <code>#bmw</code>
    
    
    
  </p> 
</figcaption>

</figure>
<img src="relevance.png" width="400"/>
Тэги окрашены в соответствии с релевантностью. Размер тэга пропорционален его популярности.</p>

<p>Как видно, TopicTensor прекрасно справился с формированием тематики ‘BMW’
и нашел много релевантных тэгов, о существовании которых большинство даже не подозревает.</p>

<p>Усложним задачу, и сформируем тематику из нескольких немецких автобрендов
 (найдем тэги, наиболее близкие к сумме векторов входных тэгов):



<figure>

<img src="cars.png" alt="Тематика, заданная тэгами `#bmw`, `#audi`, `#mercedes`, `#vw`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгами <code>#bmw</code>, <code>#audi</code>, <code>#mercedes</code>, <code>#vw</code>
    
    
    
  </p> 
</figcaption>

</figure></p>

<p>На этом примере видна способность TopicTesnor к обобщению (generalisation):
TopicTensor понял, что мы имеем в виду автомобили в целом (тэги <code>#car</code>, <code>#cars</code>).
Также понял, что в тематике надо отдать предпочтение немецким автомобилям (тэги, обведенные красным),
и сам добавил “недостающие” тэги:
<code>#porsche</code> (тоже немецкий автобренд), и варианты написания тэгов, которых не было на входе:
 <code>#mercedesbenz</code>, <code>#benz</code> и <code>#volkswagen</code></p>




<figure>

<img src="apple.png" alt="Тематика, заданная тэгом `#apple`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгом <code>#apple</code>
    
    
    
  </p> 
</figcaption>

</figure>

<p>Усложним задачу еще больше, и создадим тематику на основе неоднозначного тэга
 <code>#apple</code>, который может обозначать как бренд, так и просто фрукт.
  Видно, что тематика бренда доминирует, тем не менее фруктовая тема тоже присутствует
 в виде тэгов <code>#fruit</code>, <code>#apples</code> и <code>#pear</code>.</p>

<p>Попробуем выделить чистую “фруктовую” тематику, для этого добавим несколько тэгов, относящихся
  к бренду apple, с отрицательным веcом.
Соответственно, будем искать тэги, наиболее близкие к взвешенной сумме векторов входных тэгов (по умолчанию
вес равен единице):
$$target = \sum_i w_i \cdot tag_i $$</p>




<figure>

<img src="apple_fruit.png" alt="Тематика, заданная тэгами  `#apple`, `#iphone:-1`, `#macbook:-0.05` `#macintosh:-0.005`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгами  <code>#apple</code>, <code>#iphone:-1</code>, <code>#macbook:-0.05</code> <code>#macintosh:-0.005</code>
    
    
    
  </p> 
</figcaption>

</figure>

<p>Видно, что отрицательные веса убрали тематику бренда, и осталась
 только тематика фрукта.</p>

<p>


<figure>

<img src="mirror.png" alt="Тематика, заданная тэгом  `#mirror`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгом  <code>#mirror</code>
    
    
    
  </p> 
</figcaption>

</figure>
TopicTensor в курсе, что
одно и то же понятие может быть выражено различными словами на разных языках,
как это видно на примере с <code>#mirror</code>. К английским
<strong>mirror</strong> и <strong>reflection</strong> подобрались: <strong>зеркало</strong> и <strong>отражение</strong> на русском,
<strong>espejo</strong> и <strong>reflejo</strong> на испанском, <strong>espelho</strong> и <strong>reflexo</strong> на португальском,
<strong>specchio</strong> и <strong>riflesso</strong> на итальянском, <strong>spiegel</strong> и <strong>spiegelung</strong> на немецком.</p>

<p>


<figure>

<img src="boobs.png" alt="Тематика, заданная тэгом  `#boobs`" width="800" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Тематика, заданная тэгом  <code>#boobs</code>
    
    
    
  </p> 
</figcaption>

</figure>
На последнем примере видно, что casual тематики работают так же хорошо,
 как и брендовые.</p>

<h3 id="подбор-блоггеров">Подбор блоггеров</h3>

<p>Для каждого блогера анализируются его посты и суммируются вектора всех входящих в них тэгов.
$$\beta=\sum_i^{|posts|}\sum_j^{|tags_i|} w_{ij}$$
где $|posts|$ это кол-во постов, $|tags_i|$ это кол-во тэгов в $i$-том посте.
Результирующий вектор $\beta$ это и есть <em>тематика блогера</em>.
Затем находятся
блогеры, тематический вектор которых наиболее близок к тематическому
вектору, заданному пользователем. Список сортируется по релевантности
и выдается пользователю.</p>

<p>Дополнительно учитывается популярность блогера и количество тэгов в его постах,
т.к. в противном случае в топ вышли бы блогеры, у которых есть один пост
с одним тэгом, заданным пользователем на входе. Финальный score, по которому
сортируются блогеры, рассчитывается так:
$$score_i = {\sim{input}{\beta_i} \over \log(likes)^\lambda \cdot \log(followers)^\phi \cdot \log(tags)^\tau}$$
где $\lambda, \phi, \tau$ - эмпирически подобранные коэффициенты, лежащие в интервале $0\dots1$</p>

<p>Расчет cosine distance по всему массиву блогеров (в подборе участвует несколько миллионов аккаунтов)
занимает значительное время. Для ускорения подбора была
использована библиотека <a href="https://github.com/nmslib/nmslib" target="_blank">NMSLIB</a> (Non-Metric Space Library), позволившая
сократить время поиска на порядок. NMSLIB заранее строит индексы по
координатам векторов в пространстве, что позволяет намного быстрее вычислять
топ близких векторов, рассчитывая cosine distance только для тех кандидатов,
для которых это имеет смысл.</p>

<h3 id="демо-сайт">Демо сайт</h3>

<p>Демонстрационный сайт с ограниченным количеством тэгов и блогеров доступен
по адресу <a href="http://tt-demo.suilin.ru/" target="_blank">http://tt-demo.suilin.ru/</a>. На сайте можно самостоятельно
поэкспериментировать с формированием тематик и подбором блогеров по
сформированной тематике.</p>

<h3 id="тематические-lookalikes">Тематические lookalikes</h3>

<p>Вектора $\beta$, рассчитанные для подбора блогеров, можно использовать и для
сопоставления блогеров друг с другом. Фактически lookalikes это тот же подбор блогеров,
но вместо вектора тэгов на вход подается тематический вектор $\beta$ блогера, заданного
пользователем. На выходе получается список блогеров, тематика которых
близка тематике заданного блогера, в порядке релевантности.</p>

<h3 id="фиксированные-тематики">Фиксированные тематики</h3>

<p>В TopicTensor, как уже говорилось, нет явным образом заданных тематик.
Тем не соотнесение постов и блогеров с фиксированным набором тематики бывает необходимо,
для упрощения поиска, или для ранжирования блогеров внутри отдельных тематик.
Возникает задача по экстрагированию фиксированных тематик из векторного пространства тэгов.</p>

<p>Для решения этой задачи было выбрано unsupervised обучение, чтобы
избежать субъективности при определении возможных тематик, и чтобы
сэкономить ресурсы, т.к. просмотр сотен тысяч тегов (даже 10% из них) и присвоение им тематик
&ndash; это большая ручная работа.</p>

<p>Самый очевидный способ экстракции тематик это кластеризация векторного
представления тэгов, один кластер = одна тематика. Кластеризация проводилась в два
этапа, т.к. алгоритмов, способных эффективно искать кластера в 200D
пространстве, пока не существует.</p>

<p>На первом этапе проводилось уменьшение размерности с помощью технологии
<a href="https://github.com/lmcinnes/umap" target="_blank">UMAP</a>. Эта технология является в некотором смысле
улучшенным t-SNE (хотя основана на совершенно других принципах),
быстрее работает, и лучше сохраняет исходную
топологию данных. Размерность уменьшалась до 5D, в качестве метрики расстояния использовался cosine distance,
остальные гиперпараметры подбирались по результатам кластеризации (второго этапа).</p>




<figure>

<img src="clusters3d.png" alt="Пример кластеризации тэгов в 3D пространстве. Разные кластера помечены разными цветами (цвета не уникальны и могут повторяться для разных кластеров)." width="600" />



<figcaption data-pre="Рис. " data-post=":" >
  
  <p>
    Пример кластеризации тэгов в 3D пространстве. Разные кластера помечены разными цветами (цвета не уникальны и могут повторяться для разных кластеров).
    
    
    
  </p> 
</figcaption>

</figure>

<p>На втором этапе проводилась кластеризация алгоритмом <a href="https://github.com/scikit-learn-contrib/hdbscan" target="_blank">HDBSCAN</a> .
Результаты кластеризации (только по английскому языку)
можно увидеть <a href="https://github.com/Arturus/clusters_new/blob/master/index.md" target="_blank">в GitHub</a>.
Кластеризация выделила около 500 тематик (параметрами UMAP и кластеризации
можно регулировать кол-во тематик в широких пределах), при этом в кластера
попало 70%-80% тэгов. Визуальная
проверка показала хорошую когерентность тематик и отсутствие заметной корреляции
между кластерами. Тем не менее, для практического применения
кластера нуждаются в доработке: собрать из них дерево, убрать бесполезные
(например <a href="https://raw.githubusercontent.com/Arturus/clusters_new/master/jack.txt" target="_blank">кластер личных имён</a>,
 <a href="https://raw.githubusercontent.com/Arturus/clusters_new/master/help.txt" target="_blank">кластер негативных эмоций</a>,
 <a href="https://raw.githubusercontent.com/Arturus/clusters_new/master/people.txt" target="_blank">кластер общеупотребительных слов</a>),
  объединить некоторые кластера в одну тематику.</p>

<h2 id="возможные-улучшения">Возможные улучшения</h2>

<p>Основной недостаток TopicTensor &ndash; покрытие, далёкое от 100%. Далеко не все блогеры
используют тэги, и далеко не все, кто их используют, пишут в них что-то осмысленное.
Есть два основных способа расширить покрытие:</p>

<ol>
<li>Анализ содержимого фото. Тематика блога чётко определяется по фотографиям
(собственно, они её и задают), поэтому computer vision модель, обученная
выдавать по фотографии её тематический вектор, могла бы частично заменить тэги.</li>
<li>Если считать, что у блогеров со схожей аудиторией должна быть схожая
тематика, можно выводить тематику блогеров, не использующих тэги,
через audience lookalikes, если существуют блогеры с похожей
аудиторией и с тэгами.</li>
</ol>

    </div>

    


<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/instagram/">Instagram</a>
  
  <a class="badge badge-light" href="/tags/deep.social/">Deep.Social</a>
  
</div>



    






<div class="media author-card" itemscope itemtype="http://schema.org/Person">
  
  <img class="portrait mr-3" src="/img/me_sq.jpg" itemprop="image" alt="Avatar">
  
  <div class="media-body">
    <h5 class="card-title" itemprop="name"><a href="/">Артур Суилин</a></h5>
    <h6 class="card-subtitle">Data Scientist</h6>
    
    <ul class="network-icon" aria-hidden="true">
      
      
      
      
      
      
      <li>
        <a itemprop="sameAs" href="//www.linkedin.com/in/suilin-arthur-304b8219/" target="_blank" rel="noopener">
          <i class="fab fa-linkedin"></i>
        </a>
      </li>
      
      
      
      
      
      
      <li>
        <a itemprop="sameAs" href="//github.com/Arturus" target="_blank" rel="noopener">
          <i class="fab fa-github"></i>
        </a>
      </li>
      
      
      
      
      
      
      <li>
        <a itemprop="sameAs" href="//www.kaggle.com/asuilin" target="_blank" rel="noopener">
          <i class="fab fa-kaggle"></i>
        </a>
      </li>
      
      
      
      
      
      
      <li>
        <a itemprop="sameAs" href="//instagram.com/asuilin" target="_blank" rel="noopener">
          <i class="fab fa-instagram"></i>
        </a>
      </li>
      
    </ul>
  </div>
</div>




    
    
    
    
    
    
    
    
    

    

  </div>
</article>


<div class="article-container article-widget">
  <div class="post-nav">
  
  <div class="post-nav-item">
    <div class="meta-nav">Next</div>
    <a href="https://suilin.ru/project/gender_age/" rel="next">Определение пола и возраста по фото</a>
  </div>
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Previous</div>
    <a href="https://suilin.ru/project/geo/" rel="prev">Определение места жительства Instagram пользователей</a>
  </div>
  
</div>

</div>


<div class="container">
  <footer class="site-footer">
  

  <p class="powered-by">
    &copy; 2015-2022 &middot; Артур Суилин &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

</div>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    
    
    <script src="/js/mathjax-config.500a6cbb2c0f345fcecc21b3116d6637aa78f1f11db8081ea581abe05390c2e8f3bbffe61be3cf0217baf785c40efceabe51050a4f007e69af94efd3643260e8.js" integrity="sha512-UApsuywPNF/OzCGzEW1mN6p48fEduAgepYGr4FOQwujzu//mG&#43;PPAhe694XEDvzqvlEFCk8AfmmvlO/TZDJg6A=="></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    <script src="/js/hugo-academic.js"></script>
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    

    
    

    

    
    

    
    
    <script>
      
      window.lazyLoadOptions = {elements_selector: ".lazy"};
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/intersection-observer@0.5.1/intersection-observer.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@11.0.5/dist/lazyload.min.js"></script>

  </body>
</html>

